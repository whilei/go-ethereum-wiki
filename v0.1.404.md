# v0.1.404: Wrangling Competing Conventions in Semver Tags

Do you know what `v0.1.404` means? If you're familiar with the rules
proposed by an infamous guideline for naming version of code called _Semver_,
short for "Semantic Versioning", you'll recognize this string v-shaped word
and deduce it's meaning by breaking it into smaller pieces:

- `v`: seeing a `v` followed by some number and periods is a flag saying
  "We're using semantic versioning."
- `0`: this is the "Major

----

The heart of the difference is the PATCH number.

Some people use PATCH to reflect essentially the number of commits since a last MINOR
version. If you've ever tried counting commits since a tag with git, you may be
aware that there are some nuances to be aware of, and that exactly when you least
expect and when it's most inconvenient, you just may find yourself with the impossible:
_different_ commit counts coming from different machines.

The reason for this confusion boils down to the case that git's data is more like
a tree with branches and even multiple trunks. Like watching a tree grow on a
Planet Earth episode, the branches and "trunks" of a tree are usually pretty
dynamic. New ones are born, merge into other ones, and fall off. Counting points on
a single line is easy, but counting and ordering points on a tree is more complex.

----

Some people use PATCH __strictly__, where it's the number of commits since the last tag
for a given HEAD. This, for example, yields a tag history like:

- 3.5.0
- 3.5.86
- 3.5.92

Others use PATCH __loosely__, where it's the number of tags since the last MINOR tag.
This gives a history like:

- 3.5.0
- 3.5.1
- 3.5.2

The argument might be made for the strict version that it's more descriptive.
The drawback is that it's "harder to read," and while it is more descriptive (for people who know how `semver` is spec'd to work -- ie developers),
it's not descriptive in a useful way for lay end-users.

The argument for the "loose" way is that it looks simpler. The tag names
"talk about each other," such that you can see immediately that the tag
`3.5.1` was the next one after `3.5.0`. You know there are no tags in between them.
Whereas when you see `3.5.92` and `3.5.86`, one might wonder "But where are
`87`, `88`, `89`...?"

The problem that irks me with the "loose" way is that it's a lie. It uses
`semver` up to a point, and then arbitrarily deviates from the spec for
un-mentioned supposedly-more-friendly-for-the-users reasons. But it's mostly a lie
because using `1` when you should technically use `86` is that there's an internal
and ambiguous conflict of language. They are both integers. How do you I know
if you're using the "strict" or "loose" form of semver? To find out, I would need
to look at your git log and count the number of commits between tags. If there's just
one patch between them, then I increase my confidence in the conclusion that you're
"strict." If I find 9 commits between them, then I'll be inclined to think you're
using a "loose" system. But I won't _ever_ know for sure unless I ask you in plain
english and cross my fingers and assume you're not lying when you answer.

The problem that irks me with the "strict" way is that when I see a list of
tags, I'm not sure that I'm seeing "the whole picture". Are there any tags between
`3.5.86` and `3.5.92`? My confidence has to rest entirely with the presentation
infrastructure; what if Github missed one? We have to trust that the presentation
of the information is canonical, instead of being able to trust canonical information.

Let's consider how tags are used -- what're they good for?

Functionally, a tag is a completely arbitrary label that can be applied to
any point in a version history. It's composed (usually) of a name, eg `v3.5.1`
and a message `Fixed all the things!`. This structure is very similar to commits,
except that instead of a computer-assigned very-long-hash for a name, you get to pick the name.
Instead of semver standards, one could open a dictionary and name the first tag `Aardvark`, the next
`Amphitheater`, `Architect`, ...


Here's a proposal for consideration.

- 3.5.exquisite-mirror
- 3.5.mighty-bagel
- 3.5.hilarious-possum

Where "nightly" archive build versions might then look something like:

- 3.5.exquisite-mirror+14-ccde21
- 3.5.mighty-bagel+97-afb91f
- 3.5.hilarious-possum-babdc1

The downside of this is the same as "strict" PATCH version; it lacks
internally verified sequence. I'm not _sure_ that `exquisite-mirror` came
after `might-bagel`, or before, or if there are any tags in between.

Or, another idea:

- 3.5.zero
- 3.5.one
- 3.5.two

Which has the benefit of being clear that we're deviating from "strict"
semver definitions, while maintaining internally-verifiable increments ("zero"
comes before "one", and "two" is right after "one"). The downside is it's not alphabetical.
When you run `git rev-list --tags`, you'll have to do some serious reading
before you can find out what to name your forthcoming tag.

Another idea:

- 3.5.a
- 3.5.b
- 3.5.c

Here get our confirmable sequence, our alphabetic order, and our signal that
we're deviating from strict `semver`. The downside is that it's bland, "Woohoo!
We finally released 3.5.b!" just doesn't have the same ring to it as "Just
released the mighty bagel!". Also, we're going to run into an issue when we
need to name the 27th tag. `3.5.za`, `3.5.zb`?

Just one more idea, I swear:

- 3.5.aardvark
- 3.5.british
- 3.5.creamery
...
- 3.5.zepplin

This would fulfill the requirements (somewhat) elegantly, up until we try to
tag the 27th PATCH release for our `3.5.` series. Do we use

- `3.5.zepplin-architect`

and get another 26 PATCHES until we need `3.5.zepplin-zygote-amber` and start
the whole thing over?

or

- `3.5.zygote`

A practical solution to this is that once we're at about our 20th PATCH tag,
we could start stepping more slowly, eg

- `3.5.tangle`
- `3.5.triangle`
- `3.5.tryptich`

Which maintains order, _but_ it seems to bend a rule for no clear reason. Why
are they making a bunch of `t` words now instead of moving on incrementally to the next letter `u` and `v`?
Is there meaning to that?


----

- tags: what are they and what are they used for
- releases: how do we signify them, and how can they be different. what is pre-release?
- what's a patch? a single commit? a set of changes?
- increment

